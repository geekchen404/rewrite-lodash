# Hook笔记
  ## 函数组件
    没有生命周期函数，没有内部state
  ## useState
    通过useState来定义函数组件内部的state
    var [state1,setState] = useState(0)这个0就是
    var [count,setCount] = useState(0)
     
    对于函数组件来说，更新state，就是重新刷新整个函数组件，重新运行
    但是userstate的时候传入的参数只会在第一次运行的时候取传入值，
    后期set之后的状态都是有内存存着的
    所以就算组件重新渲染也不会拿到初始值而是改变之后的值，因为返回的数据改变了
    所以当有多个状态的时候可以有多个usestate。但是也可以在传递初始值的时候给一个所有state的对象
    
  ## useEffect相当于是组件挂载完成和更新完成之后会执行的函数
    useEffect(()=>{这个函数不接受参数
      这个接受一个函数来处理相应的事物
      这个时候数据什么的都已经可以读取了
      return ()=>{}这里是可以返回一个函数来处理当组件被卸载的时候调用的函数
      这里返回的函数用来清除一些副作用
    })
  ## useCallback
    useCallback函数，用于函数组件之间的传递的时候把某些函数当成组件的属性传递下去的时候，因为有些函数会重新执行一遍，以至于下层的组件接受的props的某些属性改变需要重新渲染
    但是如果只是函数的改变，则不需要重新渲染，可以在定义函数的时候使用useCallback包起来，这样就不会每次刷新上层组件的时候，并没有改变的函数也会导致下层组件重新渲染
    useCallback接受两个参数，一个是需要使用的函数，一个是需要对比的数据来决定是否还是返回原来的函数，让下层组件更新，或者不更新
    用于优化性能

  useRef也是优化，让每次组件重新渲染的时候前后两次的ref不一样，使用useRef是为了让ref在函数组件之间只会定义一次，并且ref前后都是同一个


  其实以上的use的用法只是因为引入了合理的函数组件的状态之后，每次函数组件更新都会引起内部数据的重新定义，而加入这些用法只是为了让作用域还是以前的作用域 ，都不是重新执行重新定义的。