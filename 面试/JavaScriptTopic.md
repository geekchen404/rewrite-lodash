# 这是一篇关于JavaScript的全部总结文章
  ## JavaScript的数据类型（7种）
  1. JavaScript的基本数据类型
  undefined,null,bollen,number,string,symbol(es6新增)
  基本数据类型在内存中以值的形式存储在栈内存中

  2. JavaScript的复杂数据类型
  object
  复杂数据类型的值存储在堆内存，而指向值的地址存储在栈内存
  当我们把一个对象赋值给一个变量的是，复制的是地址，两个对象变量实际指向同一个内存空间

  ## JavaScript引用类型
  引用类型是一种数据结构，将数据与功能组合在一起，引用类型的值/对象就是引用类型的一个实例
  引用类型有:
  Object, Array, Date, RegExp, Function,
  (Boolen,String,Number)的基本包装类型, (Global,Math)单体内置对象类型

  ## 如何判断类型
  1. typeof 用来判断原始类型
  只能用来判断是基本类型（除了null）和object（所有引用类型都返回object）
  2. Object.prototype.toString 用来判断内置对象类型
  3. instanceof 用来判断自定义对象类型
  4. new.target，是用于判断当前函数的this是指向当前的函数，
  好了，从这里扯出了原型和原型链，又看到了构造函数和对象

  我们从js的设计开始说起，js中无法创建一个类 
  我们可以通过一个函数返回一个对象（里面有各种属性和方法）来创建一个类，
  即为用函数来封装以特定接口创建对象的细节
  可以不停的调用这个函数，得到无数个独立的实例，以继承的形式去使用构造函数的属性和方法
  但是对象太多了，你怎么知道你的这个对象是通过哪个函数实现而来的呢，都有什么方法和属性能用呢
  后来就有了首字母大写的构造函数，可以用来创建对象
  要创建一个新实例，就必须通过new调用，new调用的时候发生了什么我们后期再说
  通过new调用的实例对象都有constructor属性，该属性指向构造函数
  person1.construcor==Person（true）
  判断检测对象类型也可以通过instanceof操作符 
  person1 instanceof Person（true）
  构造函数和普通函数的区别就在于调用的方式不同
  用人，父子关系定义
  看完js高程那个图深深地印在了我的脑海里，详情见prototype的md文件
## this,bind,apply,call
  函数的this永远指向调用它的对象
##  Web Worker
  在浏览器里面，css动画是不被js影响的
  进程与线程的区别：
  不同的进程之间不能共享内存
  同一个进程的多个线程是可以共享这个进程的内存的 
  cpu的时间内片轮转是以线程为基本单位的
  浏览器中woker和传统意义上的线程不是一样的
  浏览器通worker启动的线程不能和其他线程共享内存，只能传递一份新的数据过去但是不能共享旧的内存
  现在也支持这样的功能了
  一个worker是一个被隔离的JavaScript运行环境
  根本就不是一个全局作用域，相当于两个js文件
  她和主线程是并行运行的
  只能通过发消息接收消息的形式来通信
## 为什么要有super(props)
  **我们为什么要调用super？能不能不调用它？如果非要调用，如果不传 props 会怎样？还有其它参数吗**
  因为这样之后才能使用this
  才能访问到this.props
  如果只是调用super()
  super指代父类的构造函数
  那你只能访问到props，而不是this.props
  如果不去初始化，你不去初始化this，在你的函数中你使用了父组件传下来的东西，但是你自己没有定义


