# 正则笔记
  ## 元字符
    元字符是构造正则表达式的基本元素
    常用元字符表达式
    \d   ：0到9的所有数字（一位）
    \b   ：匹配一个单词的开头或者结束位置
    \w    : [ 0-9 a-z A-Z \_ ] ,0到9，a到z，A到Z，还有一个下划线
    \s     : 匹配空格，tab，回车
    \D    : \d 取反，即出来0到9的所有字符
    \W   : \w 取反，
    \S    : \S取反，除了空格符
    \i     : 表示匹配的内容，大小写不敏感
    ^     : 在表达式开头出现，表示从字符串开头开始匹配，在 [ ] 中的开头位置出现
            表示后面的匹配内容取反（非）比如：[^01]表示非0或者非1，非开头位置只表示该符号
    &    : 和^一起出现，表示表达式匹配整个字符串，精确匹配，是否完全整个匹配
    .     : 除了回车外的所有符号，包括中文
  ## 重复限定符
    +    : 表示前面的匹配内容重复1到多次
    *     : 和+类似，但是表示前面的匹配内容重复0到多次
    ？   : 表示出现0次或者出现1次
    { 4 }: 中间是任意数字，表示精确重复出现多少次，比如重复出现4次
    {4,6}: 表示重复出现的次数在4到6之间
    {5，}: 表示重复出现的次数在5次及以上
  ## 分组符
    ( )   ：括号中的内容将作为一个整体
  ## 转义符
    \      : 后面紧跟的符号将作为一个简单符号匹配
    条件或
    |      ： 表示一种分支条件，匹配|左右的任意一个条件，
  ## 区间符
    [ ]    : 表示匹配括号中任意一个字符 ，和|类似，但是 [ ] 中只能匹配一个符号，比如[ 0-9 a-z A-Z \_ ]，匹配其中其一而已，
    注意g：在正则 / / 的后面加一个g即为//g，就是全局匹配，匹配到字符串中所有符合的子集
    如果要匹配任意字符怎么办？可以使用[\d\D]、[\w\W]、[\s\S]和[^]中任何的一个

  ## 其他笔记
    \d：表示一位数字
    重复的次数
    \d+：+表示前面的字符可以出现多次，即多个数字
    \d*：*表示出现0次，1次，多次都可以
    ？：表示出现0次或者1次
    {4}：表示精确的出现括号中的次数
    {1,4}：表示精确的出现1到4次中的任意次数
    {5,}：表示至少5次或者以上
    {,5}这个写方法是错误的，在正则里面就仅代表四个字符而已
    正则表达式可以用构造函数表示，也可以用 '/' 包裹起来
    用构造函数的时候需要注意

    在任何符号前面，都可以加一个\，表示后面的符号本身
    正则表达式的test是表示，test后面的字符串中是否符合前面表达式中所表达的模式，返回真假
    正则表达式中的[]，中括号：在中括号里面的符号只有符号的本身的意思，而没有正则表达式赋予的意义

    正则表达式中的 '-' ,中划线：表示划线两边所有的字符

    取反的^只能出现在中括号的第一个位置表示取反，其他位置没有这个意思
    \i 表示大小写不敏感
    exec也是一个正则测试方法，是正则匹配字符串
    没有匹配到会返回一个null
    匹配到会返回匹配到的内容
    而且返回的内容有个index属性，表示在哪里匹配到的
    当括号确定了，返回的数组的长度一定是确定的，
    会返回数组，数组是，第一个内容是整个正则表达式，后面的内容是正则表达式中出现的括号的匹配到的内容

    matches,是字符串匹配正则，也有index属性
    返回数组
    只会返回匹配到的第一个内容
    Date类型：表达日期和时间
    ^ 这个符号在正则表达式中出现在第一个位置，表示匹配从字符串的开头开始
    若是正则表达式由^开始，由$结束，那么匹配后面的字符串从开始到结束，即为整个字符串
    \b是表示单词边界，没有特殊的符号，只是表示一种位置
    零宽断言：匹配两个符号之间的一个位置，而不是一个符号
    匹配发生的时候，光标不会移动，所以可以对同一个位置执行多个零宽断言,只有当每个断言都成功时才可以
    有四种零宽断言
    (?=expr) 正预测零宽断言，这个位置的右边满足expr 
      (?!expr) 负预测零宽断言，这个位置的右边不满足expr
      (?<=expr) 正回顾零宽断言，这个位置的左边满足expr（旧版JS不支持）
      (?<!expr) 负回顾零宽断言，这个位置的左边不满足expr（旧版JS不支持）
    ^ === /(?<![^])/
    $ === /(?![^])/
    \b === /(?<=\w)(?=\W)|(?<=\W)(?=\w)|(?<![^])|(?![^])/
    正向先行断言（正前瞻）：
    语法：（?=pattern）
    作用：匹配pattern表达式的前面内容，不返回本身。
    正向后行断言（正后顾）:
    语法：（?<=pattern）
    作用：匹配pattern表达式的后面的内容，不返回本身。
    负向先行断言（负前瞻）
    语法：(?!pattern)
    作用：匹配非pattern表达式的前面内容，不返回本身。
    负向后行断言（负后顾）
    语法：(?<!pattern)
    作用：匹配非pattern表达式的后面内容，不返回本身。
    你那个正则的意思是，匹配 [ 后面所有的内容并且不包括 ] 的内容，你应该再加一个[就不会多一个中括号了
  ## 深入
    后向引用
    贪婪匹配
    总是先尝试最多的部分，如果匹配不到再以此减少
    非贪婪匹配：总是先尝试少的部分，在表达式前加一个？
    作业：
    使用从通配符构造一个正则表达式的办法来实现上面的函数,比如：
    match('fooobarbaz', '*bar?az')
    match('fooobarbaz', '???*baz') 
    match('fooo++++barbaz', '???*baz')
    *代表0个或多个任意字符
    ?代表1个任意字符
    正则的lastIndex属性，会对test，exec，match这几个函数都有影响
    match,
    不考虑正则表达式的lastIndex属性。
    当正则表达式有g标志的时候，匹配出所有能够满足整条正则表达式的内容
    当没g标志的时候，匹配出第一条能满足的内容，同时把分组捕获到的内容也放入结果数组
    replace(RegExp|String, String|Function)
    两个参数都是字符串：匹配第一次出现的内容为目标内容
    首参为正则
    次参为字符串，里面的$&,$1,$2是特殊内容，表示匹配到匹配到的内容以及各个分组捕获到的内容
    次参为函数，把整个匹配到的内容以及各分组捕获到的内容传给函数做为参数，把函数返回值插入被替换位置
    有多少次匹配，函数就会调用多少次
    re.exec(str)方法
    如果re不带g标志，则完全等同于str.match(re)
    如果re带有g标志，则从str的re.lastIndex位置开始查找，查找成功后把re.lastIndex置为匹配位置的后一个位置
    查找不成功的时候，返回null，把lastIndex置为0
    str.split(String|RegExp)
    当参数是字符串时，按字符串把原字符串拆成数组
    当参数为正则时，按正则把原字符串拆成各部分的数组
    但是当正则里有捕获分组时，分组捕获到的内容也会出现在结果数组的相应位置
    onkeyup,当键盘松手的时候，在input中的时候
    实现正则匹配的实时高亮效果（难）
    作业：输入的字符串没有任何多余的空格
    解析json的字符串的函数ParseJSON
    就是，实现json.parse的函数或者json.string函数
    y和g是一样的用法，但是y的意思是严格匹配，只会从当前的位置开始匹配，不会跳过
    string.raw`shwuw`这里是什么返回什么，用于正则的构造函数，可以自己实现这个函数
    argument里面有一个raw属性，是得到的字符串不转义的结果
  ## 扩展
    exec是正则表达式的正则对象RegExp的一个方法、
    这个方法接受一个字符串，但是返回数据有多重情况，可以从exec入手，自己实现其他的正则的函数
    /.../.exec(str)
    返回的数据里面有几个非常重要的属性
    匹配不成功只会返回一个null
    若是匹配成功，则有两种情况，正则表达式带g和不带g
    有一下几个属性，比较重要
    1.index：表示找到的匹配到的字符串的第一个下标
    2.input：表示传入的str
    3.lastIndex：表示匹配成功一个之后，下次开始匹配的位置（只在有g的情况下有效）
    在使用正则的时候也要注意（）的用法，会影响函数返回的数据





