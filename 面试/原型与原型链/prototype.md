# 原型与原型链
## 原型
说起原型就要先说起工厂模式
在js中没有类的概念，但是我们可以通过函数返回一个对象来实现相似的一个类的定义
**从工厂模式->构造函数模式->原型模式->构造函数和原型组合模式都是对特定类型的对象的封装**
1. 工厂模式：
即为用函数来封装以特定接口创建对象的细节，但是他有缺点，没有办法通过对象识别该类型
构造函数模式：把属性和方法都挂载构造函数返回的this上面，只能通过new调用，构造函数首字母大写，可以通过instanceof来识别对象与原型之间是否有关系
2. 原型模式：
是将原本的构造函数清空，将属性和方法都在外部通过该构造函数的prototype来挂载，所有的属性和方法都可以通过prototype这个属性来访问。所以prototype是一个指针，指向一个对象，而这个对象就是原型对象，里面有所有共享给实例的属性和方法，即为prototype就是实例的原型对象，一般来说，这个原型对象还有一个constructor属性指向自己的构造函数
3. 构造函数和原型的组合模式：
因为如果所有属性和方法都在prototype上面的话，任何一个实例也可以通过原型链来更来原型对象上面的属性，其他所有的实例也会因此更改该属性，所以构造函数里面定义实例的属性，prototype属性来指定共享的所有属性和方法，这样属性在每次new调用将属性继承给实例对象的时候都是独立并且唯一的，都不会在实例对象之间有影响，而方法也可以共享出去，所有实例都调用的一个方法
4. 后面还有很多，但是构造函数和原型的组合模式是最主要的一种，理解到这里就好啦

## 原型链
js是通过原型链来实现继承的，原型链的构建通过将一个类型的实例赋值给另一个构造函数的原型而实现的
原型链是作为实现继承的主要方法，其基本的思想就是利用原型让一个引用类型继承另一个引用类型的属性和方法
原型链构成的是实例与原型之间的链条
当原型对象变为另一个对象的实例的时候，就是继承了来自另一个对象的全部属性和方法，
当构造函数创建了一个新对象之后就会在实例的内部产生一个[[Prototype]]指针（即为_proto_），指向该实例的构造函数的原型对象
  ### 原型链的继承方式
  有以下几种
   #### 原型链继承
   通过a.prototype = new B()
   那么这里的a的原型对象直接指向了B的实例
   带来的缺点是，实例会共享原型链上面的方法，一旦被修改，所有实例的原型链上的方法都被修改
   #### 借用构造函数/伪造继承/经典继承
   在子类型的构造函数内部调用超类型的构造函数
   即为在构造函数内部去绑定需要继承的构造函数
   但是这种方法还是构造函数模式，没有实现真正的函数复用，不建议也很少使用
   #### 组合继承
   这个方法结合了原型链继承方式和借用构造函数继承方法组合在一起
   和原型模式一样，属性放在构造函数里面，共享的方法放在原型对象上new继承
   这个是比较好的方法，目前最常用的继承方法
   但是都会调用两次，其实最终都会包含，一次call的时候，一次是new的时候 
   ```js
   // 组合继承
    function SuperType(name) {
      this.name = name
      this.color = ['red', 'blue', 'green']//构造函数有个数组
    }
    SuperType.prototype.sayname = function () {
      alert(this.name)
    }
    function SubType(name, age) {
      SuperType.call(this, name)//借用构造函数继承
      this.age = age
    }
    SubType.prototype = new SuperType()//原型链继承
    // 这样一来属性独立，方法共享，是最常用的继承方式
   ``` 
   #### 原型式继承
   道格拉斯提出的一种方法，有一个object函数接受一个对象作为参数
   ```js
   function object(o){
     function F(){}//一个空的构造函数
     F.prototype = o //重新定义原型对象
     return new F() //返回构造函数的实例
   }
   ```
   后来直接有了object.create(obj1,obj2)方法来实现继承，
   接受两个参数，两个对象，一个是原型对象，一个是属性对象
   但是还是摆脱引用类型被共享，可能被修改影响所有实例的命运
   #### 寄生式继承
   寄生式继承结合了原型式继承，并讲为实例自身增加自有属性的步骤一起封装到了一个函数里面
   其实原型式继承和寄生式继承都是对一些基本原型模式的封装
   ```js
   //寄生式继承的实现
   function createAnother(prototype){//传入一个原型对象或者对象
     let obj = object(prototype)//这里是使用了原型式继承，上面的代码
     obj.sayname = function (){
       alert('hi')
     }
     return obj//返回一个完全封装好的实例对象
   }
   ```
   但是缺点是为对象单独添加的方式依然不能做到真正的函数复用降低效率
  #### 寄生组合式继承
  就是一种结合了构造函数和原型链的方式来继承的，组合继承的优化方案
  通过寄生的方式来继承其他的构造函数
  例子如下：
  ```js
  // subtype,supertype这两个是构造函数
  function innerPrototype(subtype,supertype){
    var prototype = object(supertype.prototype) //创建实例，
    // 这里是得到了一个新的构造函数的实例，并且构造函数的原型对象为supertype的原型对象
    // 即为：prototype._proto_ => supertype.prototype
    prototype.constructor = subtype//增强实例
    // 这个原型的构造函数指向另一个构造函数
    subtype.prototype = prototype //指定对象
    // 传进来的对象的原型对象指向新的对象，这个对象继承了super
  }

  // 这个函数的作用是让subtype这个构造函数继承supertype这个构造函数

  function object(o){
    function F(){}//一个空的构造函数
    F.prototype = o //重新定义原型对象
    return new F() //返回构造函数的实例
   }
  // 比如：
  function SuperType(name){
     this.name = name
     this.color = ['red', 'blue', 'green']
  }
  SuperType.prototype.sayName = function (){
    alert(this.name)
  }
  function SubType(name,age){
    SuperType.call(this,name)
    this.age = age
  }
  innerPrototype(SubType,SuperType)//用这个重新指了原型对象而已
  // 其实这里好在没有使用new，只是直接拿了超类型构造函数的原型对象，并且把构造函数的指针指向自己了而已
  SubType.prototype.sayAge = function(){
    alert(this.age)
  }
  ```

## 原型模式的比如
比如工厂，工厂要生产一批碗，一开始工人自己一个一个用泥巴捏碗，又慢又需要大批人手，而且很多碗都打不到使用标准，怎么办呢
找一个最好的师傅，捏一个碗，用这个碗做成模具，大家都用这个模具一起生产，这样就快了很多，把你泥巴放进去碗就成型了。但是供不应求，碗有了更多的标准，大家做出来之后还得加工画画写字上去，更加好看，卖的好，而且还有了不同的分类
通过最开始的那个模具，产生了大一号的碗小一号的碗的各种模具，我还可以通过模具再做一个模具，我也可以自己照着自己的想法做模具。每个碗就是这样来的

但是工厂要正规啊，你的碗不合格怎么办，你的碗卖得好我要表扬怎么办，我怎么哪个碗是哪个模具出品的呢

所以碗和模具被创造出来的时候就增加了一个条形码，通过条形码得到是哪个模具加工雕刻的，又通过那个模具知道那个可以雕刻的磨具是从哪个模具生产过来的，还可以知道是哪个师傅做的，最后都会追溯到最开始那个师傅的第一个碗的模具，大家的碗其实都是从那儿来的，那个才是根本

最开始的碗，是object，那个模具是prototype原型对象，那个条形码是[[Prototype]]指向原型对象的指针，constructor就可以知道是哪个师傅做的碗
重新写prototype,就是悄咪咪换了模具


## 总结
原型和原型链一定要知道prototype(是共享)和[[Prototype]](是继承)
每一个函数都会有自己prototype原型对象，存放共享出去的东西，但是原型对象也可以继承，每个原型对象都可以有一个[[Prototype]]指针，指向别的构造函数的原型对象，实际上是别的原型对象的实例
但是都是通过[[Prototype]]去查找每一个原型对象和每一个原型对象继承自哪个原型
原型只是实现了构造函数和实例的两两之间的共享关系
而原型链的各种继承方式其实就是，要么new继承，要是改变原型指针和constructor的指针，在进行封装而已
**本质就是构造函数和原型对象和原型指针的多样性**
但是原型链才是真的实现了继承，即为让一个原型对象的原型链属性指向另一个原型的对象
相关方法：instanceof，isprototypeOf，hasOwnproperty，getpropertyOf,Object.defineProperty(),

## 注意
  注意这里也会扯出instanceof相关的问题，比如instanceof和typeeof的区别
  instanceof在于，会在原型链上进行查找
  typeof是对于类型的判断，没有继承关系的查找，类别也就那么几种数据类型
  还有object.prototype.toString.call(obj)

