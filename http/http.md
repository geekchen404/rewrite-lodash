# http 记录
  ## HTTP是什么
  HTTP是不保存状态的协议，既无状态协议
  协议本身对于请求或响应之间的通信状态不进行保存，因此连接双方不能知晓对方当前的身份和状态。
  这也是Cookie技术产生的重要原因之一：客户端的状态管理。
  浏览器会根据从服务器端发送的响应报文内 Set-Cookie 首部字段信息自动保持 Cookie。
  而每次客户端发送 HTTP 请求，都会在请求报文中携带 Cookie，作为服务端识别客户端身份状态的标识。
  
  ## 重要概念解读
  是关于串行连接、持久连接、管道化持久连接、http/2.0多路复用简介
   ### 串行连接
   http是建立在tcp上面的一次请求一次响应模型，每一个响应后都会断开tcp的链接
   故而，每次发起http请求都会重新进行一次tcp连接，这样也太麻烦了吧
   这就是http/1.0的版本，也叫作串行连接或者短连接或者短轮询
   ### 持久连接，也叫作长连接长轮询
   为了解决上面的问题，HTTP/1.1实现并默认了所有的链接都采用持久连接
   即为，客户端和服务端双方都没有提出断开连接的话就会在一定时间内保持tcp的连接
   以保证一段时间内同一个域名下的http请求的复用，这样就减少了多次http请求造成的tcp三次握手和四次挥手的次数
   但是这个连接采用的是拥塞模式，就是只有上次的请求得到了响应才会发起下一次的请求
   如果上次请求的内容还没有返回就只能等着，常说的线头阻塞
   也就是http-alive
   ### 管道化持久连接
   就是解决了线头阻塞，在持久连接的基础上实现了不用等待上次响应返回可以直接发送请求，并安札顺序返回响应
   但是现代浏览器并没有默认开启管道化
   在持久连接的基础上，可以并发请求，而且多次发送不需要上次的等待
   ### http/2.0多路复用
   就是在客户端增加一个序列标识符，客户端可以并发发送请求
   服务端会根据标识符自己排序为不同的请求报文，再并发返回响应
   客户端接收到响应也会根据序列标识符重新排序归入各自的请求报文
   并且同一个域名下的http连接都复用同一个tcp连接
   增加了服务器并发处理的上限
   ### webSocket
   是html5提出的一种客户端和服务端之间的全双工协议
   通过客户端建立链接之后不仅客户端可以像服务端发送消息，
   服务端也可以像客户端发送消息
   ## Cookie
  比如用来记住状态，保存状态
  服务端发送头部set-cookie
  客户端，即为浏览器就会在发送请求的时候带上cookie的值
  这样服务器再接受到cookie的值的时候就去去对比信息，这次是谁和我说话
  cookie像是两个人沟通的暗号
  如果你没有告诉我暗号，我就告诉你，下次找我的时候说暗号，
  这样我就知道你是你，我就知道上次和你聊到啥时候了，咱俩介绍聊

  ## HTTP版本相关
   ### HTTP/1.0
   就是最简单的一次请求响应就断开tcp连接的协议版本
   ### HTTP/1.1 
    1. 引入了很多的缓存控制策略，比如：
       cache-control:
                      no-cache（强制向服务器再次验证）
                      no-store（不做任何缓存）
                      max-age=111111（资源可缓存最大时间 秒）
                      public（客户端、代理服务器都可利用缓存）
                      private（代理服务器不可用缓存）
    2. 增加了允许请求范围，即为在请求头中加入Range头部
      这个在于，客户端已经有了一部分内容了，再次响应的时候为了节省带宽就希望请求内部的其他部分
      就可以使用这个range来标明内容对象的偏移和长度，并且响应状态为206
    3. 请求消息和响应消息都支持host头部
      引入host是因为以前默认每台服务器都只有一个ip地址，但是后来服务器可能有多个虚拟主机，
      共享一个ip，这个时候就需要host来标明是哪个主机了
    4. 默认开启持久连接，用keepAlive
      在1.0中如果要保持长连接就需要增加请求头：content-type:keep-alive
      但是在1.1中就默认为长连接，不需要加请求头，但是可以通过Connection:close来关闭长连接
    5. chunked编码传输
      该编码将实体分块传输，并标明长度，知道长度为0的时候结束，这个在于数据量未知的时候比较好用
    6. 新增了 OPTIONS,PUT, DELETE, TRACE, CONNECT
   ### HTTP/2.0
    1. 新的二进制格式，将原本的文本协议解析改为为二进制格式
    2. 支持多路复用
    3. 头部压缩
    4. 服务端推送
   ### HTTP/3.0
    1. 避免包阻塞
    2. 快速重启会话
  
  ## 状态码
   1. 2开头的是请求成功
      1. 200 请求成功
      2. 204 请求成功，但是响应没有主体内容
      3. 206 请求响应内容的范围成功
   2. 3开头的重定向
      1. 301 永久重定向
      2. 302 临时重定向，应该是用get方法，重新像新的页面请求
      3. 307 也是临时重定向，但是保持请求方法不变
   3. 4开头的客户端错误
      1. 400 bad request,请求存在语法错误
      2. 401 unauthorized，需要通过http认证的信息才能发送请求，没有权限  
      3. 403 forbidden，请求被服务器拒绝
      4. 404 	not found，没有在服务器上找到该资源
   4. 5开头的是服务端错误
      1. 500  internal sever error ，服务器在执行请求的时候发生了错误
      2. 501  Not Implemented，服务器不支持当前请求所需要的某改能
      3. 503  service unavailable，服务器错误，无法处理请求，可能服务器没有启动或者超负载

  ## HTTP报文

  ## Web服务器
    ### 虚拟主机
    1.1规范允许一台物理服务器（一个ip地址）搭建多个web站点
    所以就有了一个服务器有多个虚拟主机
    当一个用户访问了一个网页的时候就会通过dns域名系统解析为ip地址
    通过ip地址找到对应的物理服务器在通过请求首部的host字段决定你应该访问哪个虚拟主机
    ### 代理服务器
    代理服务器是客户端和服务器之间的中间服务器，http请求由代理服务器发送给真实的服务器，在通过代理服务器返回数据。
    又分为正向代理和反向代理
    1. 正向代理（科学上网用）
       当客户端告诉代理服务器我要访问谁，中间商就去帮我访问谁。
       但是真正的源服务器不会知道我是谁，向原服务器隐藏你过来真实客户端的身份
       （你告诉代理商你要去哪儿就好了）
    2. 反向代理（跨域使用）
       反向代理是客户端向反向代理服务器发送消息，反向代理服务器自己判断应该走向何处，
       再讲得到的数据返回给客户端，我们可以甚至可以把反向代理当做是真正的服务器，正常发送请求就好了
       当我们本地的浏览器localhost页面请求外部的接口的时候肯定是跨域了，
       所以我们可以直接向自己localhost的服务器发送请求，由这个服务器去访问我们配置的接口，就不存在跨域的问题了（你需要配置你自己的反向代理，接收到请求应该去哪儿）

    ### 缓存服务器
    缓存服务器是一种提高客户端访问数据的速度的一种方法
    将用户经常访问的网络内容放在距离用户更近的中间服务器里面
    每次发起http请求的时候就向中间服务器进行鉴权验证啊，缓存匹配等
    如果都没有再向源服务器发起请求
    缓存服务器就是中间服务器，用来做缓存提高效率用的

  ## HTTPS
     https添加了加密措施，除了客户端和目标服务器，别人不知道我们在做什么数据交换
     有对称加密，非对称加密，混合加密和SSL
     1. 对称加密
     2. 非对称加密
     3. 混合加密
     4. SSL协议
     5. https的优点
        1. 内容加密：采用混合加密技术，中间者无法直接查看明文内容
        2. 验证身份：通过证书认证客户端访问的是自己的服务器
        3. 保护数据完整性：防止传输的内容被中间人冒充或者篡改
     6. http和https的区别
       1. HTTPS协议需要到CA（证书颁发机构）申请证书，一般免费证书很少，需要交费。
       2. HTTP协议运行在TCP之上，所有传输的内容都是明文，HTTPS运行在SSL/TLS之上，SSL/TLS运行在TCP之上     所有传输的内容都经过加密的。
       3. HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。
       4. http的连接很简单，是无状态的；
          HTTPS协议是由HTTP+SSL协议构建的可进行加密传输、身份认证的网络协议，可以有效的防止运营商劫持
          解决了防劫持的一个大问题，比http协议安全。
 

  ## Web安全防范
    ### XSS
      跨站脚本攻击
    ### CSRF
      跨站请求伪造
    ### 点击劫持
      iframe欺骗
    ### 中间人攻击
      https可以防止中间人攻击
  ## 个人记录
  ```js
    401：未授权，未登录
    404：未找到，not found

    强制缓存的响应头：cache-control（也能使请求头也能使响应头）
    age
    expires
    这三个都是缓存的响应头
    当用户强制刷新，有清除缓存
    http缓存是面试的重中之重


    请求头和响应头，自己也可以添加，非常容易扩 展，也需要服务器认可
    http协议本身就是文本协议，
    user-agent：浏览器的标识，js通过navigator.useragent读出这个内容，表明自己的身份，
    referer:此次页面正在被哪个页面使用，可以用来做防盗链
    防盗链：你自己的页面上使用了自己的服务器上的图片，那么久可以返回
    但是，如果别人的网页上访问了自己服务器上的图片，就不会给返回，因为referer不是自己旗下的网站

    content-security-policy，限制这个浏览器上的js资源是否能被其他的网站加载
    也可以禁止，简称csp

    跨站请求伪造，CSRF，原因在于就算是跨域请求，但是也会发出去，服务器也会处理
    如何防范呢
    通过referer判断是否是自己的网站的请求
    多加一个传输字段，设置请求数据是随时变化的，就是增加一个token令牌/钥匙，请求数据时必须加上
    CORS:未解决跨域问题出现的,有下面几个头
    access-control-allow-origin//对于某个域的请求同意，大多为*
    access-control-allow-methods//接受的请求方式
    access-control-allow-headers
    access-control-max-age//多少时间内不需要再次发送预检请求
    注意：什么时候有预检请求，什么时候没有
    注意：知道这四个cors的头的意思


    在很多网站上面，请求响应头是可以自己添加的

    content-length和keep-alive一起使用可以实现pipe line
    还有可以做连接复用
    pipe-alive表示tcp链接不要断开
    同时也需要响应头的长度发出来

    跨域的时候，浏览器会发一个预检请求，查看该请求是否能够请求权限
    预检请求是OPTIONS的请求方式，带着referer和host给服务请发送请求
    那么如果能够跨域请求的话就返回一个access-control-allow-origin：*
    并且可以带着age，表示多少时间内对于该请求都不需要再次发送预检请求，
    但是并不是所有的跨域请求都会触发预检请求
    预检请求：preflight request

    ```


    aria是一款下载软件
    启动后监听用户的请求
    是通过http请求和json 


    restful 接口规范和rpc协议

